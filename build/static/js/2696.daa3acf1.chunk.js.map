{"version":3,"file":"static/js/2696.daa3acf1.chunk.js","mappings":"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","sources":["../node_modules/@safe-global/safe-apps-sdk/src/version.ts","../node_modules/@safe-global/safe-apps-sdk/src/communication/utils.ts","../node_modules/@safe-global/safe-apps-sdk/src/communication/messageFormatter.ts","../node_modules/@safe-global/safe-apps-sdk/src/communication/methods.ts","../node_modules/@safe-global/safe-apps-sdk/src/communication/index.ts","../node_modules/@safe-global/safe-apps-sdk/src/types/sdk.ts","../node_modules/@safe-global/safe-apps-sdk/src/txs/index.ts","../node_modules/@safe-global/safe-apps-sdk/src/eth/constants.ts","../node_modules/@safe-global/safe-apps-sdk/src/eth/index.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/data/concat.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/formatAbiItem.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/data/isHex.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/data/size.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/version.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/base.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/abi.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/address.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/encoding.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/lru.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/data.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/data/pad.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/fromHex.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/toHex.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/toBytes.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/@noble/hashes/src/_u64.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/@noble/hashes/src/utils.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/@noble/hashes/src/sha3.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/keccak256.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/address/getAddress.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/address/isAddress.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/data/slice.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/regex.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/hashSignature.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/abitype/src/regex.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/toSignature.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/normalizeSignature.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/abitype/src/human-readable/formatAbiItem.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/toSignatureHash.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/toFunctionSelector.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/prepareEncodeFunctionData.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/encodeFunctionData.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/constants/strings.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/signature/hashMessage.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/signature/toPrefixedMessage.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/errors/typedData.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/stringify.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/typedData.ts","../node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/signature/hashTypedData.ts","../node_modules/@safe-global/safe-apps-sdk/src/safe/signatures.ts","../node_modules/@safe-global/safe-apps-sdk/src/types/permissions.ts","../node_modules/@safe-global/safe-apps-sdk/src/wallet/index.ts","../node_modules/@safe-global/safe-apps-sdk/src/decorators/requirePermissions.ts","../node_modules/@safe-global/safe-apps-sdk/src/safe/index.ts","../node_modules/@safe-global/safe-apps-sdk/src/sdk.ts","../node_modules/@safe-global/safe-apps-sdk/src/index.ts"],"sourcesContent":["export const getSDKVersion = () => '9.1.0';\n","// i.e. 0-255 -> '00'-'ff'\nconst dec2hex = (dec: number): string => dec.toString(16).padStart(2, '0');\n\nconst generateId = (len: number): string => {\n  const arr = new Uint8Array((len || 40) / 2);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, dec2hex).join('');\n};\n\nconst generateRequestId = (): string => {\n  if (typeof window !== 'undefined') {\n    return generateId(10);\n  }\n\n  return new Date().getTime().toString(36);\n};\n\nexport { generateRequestId };\n","import { ErrorResponse, SDKRequestData, RequestId, SuccessResponse, MethodToResponse } from '../types/index.js';\nimport { getSDKVersion } from '../version.js';\nimport { Methods } from './methods.js';\nimport { generateRequestId } from './utils.js';\n\nclass MessageFormatter {\n  static makeRequest = <M extends Methods = Methods, P = unknown>(method: M, params: P): SDKRequestData<M, P> => {\n    const id = generateRequestId();\n\n    return {\n      id,\n      method,\n      params,\n      env: {\n        sdkVersion: getSDKVersion(),\n      },\n    };\n  };\n\n  static makeResponse = (id: RequestId, data: MethodToResponse[Methods], version: string): SuccessResponse => ({\n    id,\n    success: true,\n    version,\n    data,\n  });\n\n  static makeErrorResponse = (id: RequestId, error: string, version: string): ErrorResponse => ({\n    id,\n    success: false,\n    error,\n    version,\n  });\n}\n\nexport { MessageFormatter };\n","export enum Methods {\n  sendTransactions = 'sendTransactions',\n  rpcCall = 'rpcCall',\n  getChainInfo = 'getChainInfo',\n  getSafeInfo = 'getSafeInfo',\n  getTxBySafeTxHash = 'getTxBySafeTxHash',\n  getSafeBalances = 'getSafeBalances',\n  signMessage = 'signMessage',\n  signTypedMessage = 'signTypedMessage',\n  getEnvironmentInfo = 'getEnvironmentInfo',\n  getOffChainSignature = 'getOffChainSignature',\n  requestAddressBook = 'requestAddressBook',\n  wallet_getPermissions = 'wallet_getPermissions',\n  wallet_requestPermissions = 'wallet_requestPermissions',\n}\n\nexport enum RestrictedMethods {\n  requestAddressBook = 'requestAddressBook',\n}\n","import { MessageFormatter } from './messageFormatter.js';\nimport { Methods } from './methods.js';\nimport { InterfaceMessageEvent, Communicator, Response, SuccessResponse } from '../types/index.js';\n\n// eslint-disable-next-line\ntype Callback = (response: any) => void;\n\nclass PostMessageCommunicator implements Communicator {\n  private readonly allowedOrigins: RegExp[] | null = null;\n  private callbacks = new Map<string, Callback>();\n  private debugMode = false;\n  private isServer = typeof window === 'undefined';\n\n  constructor(allowedOrigins: RegExp[] | null = null, debugMode = false) {\n    this.allowedOrigins = allowedOrigins;\n    this.debugMode = debugMode;\n\n    if (!this.isServer) {\n      window.addEventListener('message', this.onParentMessage);\n    }\n  }\n\n  private isValidMessage = ({ origin, data, source }: InterfaceMessageEvent): boolean => {\n    const emptyOrMalformed = !data;\n    const sentFromParentEl = !this.isServer && source === window.parent;\n    const majorVersionNumber = typeof data.version !== 'undefined' && parseInt(data.version.split('.')[0]);\n    const allowedSDKVersion = typeof majorVersionNumber === 'number' && majorVersionNumber >= 1;\n    let validOrigin = true;\n    if (Array.isArray(this.allowedOrigins)) {\n      validOrigin = this.allowedOrigins.find((regExp) => regExp.test(origin)) !== undefined;\n    }\n\n    return !emptyOrMalformed && sentFromParentEl && allowedSDKVersion && validOrigin;\n  };\n\n  private logIncomingMessage = (msg: InterfaceMessageEvent): void => {\n    console.info(`Safe Apps SDK v1: A message was received from origin ${msg.origin}. `, msg.data);\n  };\n\n  private onParentMessage = (msg: InterfaceMessageEvent): void => {\n    if (this.isValidMessage(msg)) {\n      this.debugMode && this.logIncomingMessage(msg);\n      this.handleIncomingMessage(msg.data);\n    }\n  };\n\n  private handleIncomingMessage = (payload: InterfaceMessageEvent['data']): void => {\n    const { id } = payload;\n\n    const cb = this.callbacks.get(id);\n    if (cb) {\n      cb(payload);\n\n      this.callbacks.delete(id);\n    }\n  };\n\n  public send = <M extends Methods, P, R>(method: M, params: P): Promise<SuccessResponse<R>> => {\n    const request = MessageFormatter.makeRequest(method, params);\n\n    if (this.isServer) {\n      throw new Error(\"Window doesn't exist\");\n    }\n\n    window.parent.postMessage(request, '*');\n    return new Promise((resolve, reject) => {\n      this.callbacks.set(request.id, (response: Response<R>) => {\n        if (!response.success) {\n          reject(new Error(response.error));\n          return;\n        }\n\n        resolve(response);\n      });\n    });\n  };\n}\n\nexport default PostMessageCommunicator;\nexport * from './methods.js';\n","import { ChainInfo as _ChainInfo } from '@safe-global/safe-gateway-typescript-sdk';\n\nexport type ChainInfo = Pick<\n  _ChainInfo,\n  'chainName' | 'chainId' | 'shortName' | 'nativeCurrency' | 'blockExplorerUriTemplate'\n>;\n\nexport { NativeCurrency } from '@safe-global/safe-gateway-typescript-sdk';\n\nexport type BaseTransaction = {\n  to: string;\n  value: string;\n  data: string;\n};\n\nexport type GetTxBySafeTxHashParams = {\n  safeTxHash: string;\n};\n\nexport interface SendTransactionRequestParams {\n  safeTxGas?: number;\n}\n\nexport interface SendTransactionsParams {\n  txs: BaseTransaction[];\n  params?: SendTransactionRequestParams;\n}\n\nexport type GetBalanceParams = { currency?: string };\n\nexport type SignMessageParams = {\n  message: string;\n};\n\nexport interface TypedDataDomain {\n  name?: string;\n  version?: string;\n  chainId?: string | number | bigint | { toNumber: () => number };\n  verifyingContract?: string;\n  salt?: string;\n}\n\nexport interface TypedDataTypes {\n  name: string;\n  type: string;\n}\n\nexport type TypedMessageTypes = { [key: string]: TypedDataTypes[] };\n\nexport type EIP712TypedData = {\n  domain: TypedDataDomain;\n  types: TypedMessageTypes;\n  message: Record<string, any>;\n  primaryType?: string;\n};\n\nexport type SignTypedMessageParams = {\n  typedData: EIP712TypedData;\n};\n\nexport type SendTransactionsResponse = {\n  safeTxHash: string;\n};\n\nexport type OffChainSignMessageResponse = {\n  messageHash: string;\n};\n\nexport type SignMessageResponse = SendTransactionsResponse | OffChainSignMessageResponse;\n\nexport type SafeInfo = {\n  safeAddress: string;\n  chainId: number;\n  threshold: number;\n  owners: string[];\n  isReadOnly: boolean;\n};\n\nexport type SafeInfoExtended = SafeInfo & {\n  nonce: number;\n  implementation: string;\n  modules: string[] | null;\n  fallbackHandler: string | null;\n  guard: string | null;\n  version: string | null;\n};\n\nexport type EnvironmentInfo = {\n  origin: string;\n};\n\nexport type PostMessageOptions = {\n  transfer?: any[];\n};\n\nexport type AddressBookItem = {\n  address: string;\n  chainId: string;\n  name: string;\n};\n\nexport const isObjectEIP712TypedData = (obj?: unknown): obj is EIP712TypedData => {\n  return typeof obj === 'object' && obj != null && 'domain' in obj && 'types' in obj && 'message' in obj;\n};\n","import { Methods } from '../communication/methods.js';\nimport {\n  GatewayTransactionDetails,\n  SignMessageParams,\n  SendTransactionsParams,\n  GetTxBySafeTxHashParams,\n  Communicator,\n  SendTransactionsResponse,\n  SignTypedMessageParams,\n  EIP712TypedData,\n  isObjectEIP712TypedData,\n  SignMessageResponse,\n} from '../types/index.js';\n\nclass TXs {\n  private readonly communicator: Communicator;\n\n  constructor(communicator: Communicator) {\n    this.communicator = communicator;\n  }\n\n  async getBySafeTxHash(safeTxHash: string): Promise<GatewayTransactionDetails> {\n    if (!safeTxHash) {\n      throw new Error('Invalid safeTxHash');\n    }\n\n    const response = await this.communicator.send<\n      Methods.getTxBySafeTxHash,\n      GetTxBySafeTxHashParams,\n      GatewayTransactionDetails\n    >(Methods.getTxBySafeTxHash, { safeTxHash });\n\n    return response.data;\n  }\n\n  async signMessage(message: string): Promise<SignMessageResponse> {\n    const messagePayload = {\n      message,\n    };\n\n    const response = await this.communicator.send<Methods.signMessage, SignMessageParams, SignMessageResponse>(\n      Methods.signMessage,\n      messagePayload,\n    );\n\n    return response.data;\n  }\n\n  async signTypedMessage(typedData: EIP712TypedData): Promise<SignMessageResponse> {\n    if (!isObjectEIP712TypedData(typedData)) {\n      throw new Error('Invalid typed data');\n    }\n\n    const response = await this.communicator.send<\n      Methods.signTypedMessage,\n      SignTypedMessageParams,\n      SignMessageResponse\n    >(Methods.signTypedMessage, { typedData });\n\n    return response.data;\n  }\n\n  async send({ txs, params }: SendTransactionsParams): Promise<SendTransactionsResponse> {\n    if (!txs || !txs.length) {\n      throw new Error('No transactions were passed');\n    }\n\n    const messagePayload = {\n      txs,\n      params,\n    };\n\n    const response = await this.communicator.send<\n      Methods.sendTransactions,\n      SendTransactionsParams,\n      SendTransactionsResponse\n    >(Methods.sendTransactions, messagePayload);\n\n    return response.data;\n  }\n}\n\nexport { TXs };\n","export const RPC_CALLS = {\n  eth_call: 'eth_call',\n  eth_gasPrice: 'eth_gasPrice',\n  eth_getLogs: 'eth_getLogs',\n  eth_getBalance: 'eth_getBalance',\n  eth_getCode: 'eth_getCode',\n  eth_getBlockByHash: 'eth_getBlockByHash',\n  eth_getBlockByNumber: 'eth_getBlockByNumber',\n  eth_getStorageAt: 'eth_getStorageAt',\n  eth_getTransactionByHash: 'eth_getTransactionByHash',\n  eth_getTransactionReceipt: 'eth_getTransactionReceipt',\n  eth_getTransactionCount: 'eth_getTransactionCount',\n  eth_estimateGas: 'eth_estimateGas',\n  safe_setSettings: 'safe_setSettings',\n} as const;\n","import { RPC_CALLS } from '../eth/constants.js';\nimport {\n  BlockNumberArg,\n  RpcCallNames,\n  Communicator,\n  Log,\n  BlockTransactionString,\n  BlockTransactionObject,\n  Web3TransactionObject,\n  RPCPayload,\n  TransactionConfig,\n  Web3TransactionReceiptObject,\n  PastLogsOptions,\n  SafeSettings,\n} from '../types/index.js';\nimport { Methods } from '../communication/methods.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Formatter = (arg: any) => any;\n\nconst inputFormatters: Record<string, Formatter> = {\n  defaultBlockParam: (arg = 'latest') => arg,\n  returnFullTxObjectParam: (arg = false): boolean => arg,\n  blockNumberToHex: (arg: BlockNumberArg): string =>\n    Number.isInteger(arg) ? `0x${arg.toString(16)}` : (arg as string),\n};\n\ntype BuildRequestArgs = {\n  call: RpcCallNames;\n  formatters?: (Formatter | null)[];\n};\n\nclass Eth {\n  public call;\n  public getBalance;\n  public getCode;\n  public getStorageAt;\n  public getPastLogs;\n  public getBlockByHash;\n  public getBlockByNumber;\n  public getTransactionByHash;\n  public getTransactionReceipt;\n  public getTransactionCount;\n  public getGasPrice;\n  public getEstimateGas;\n  public setSafeSettings;\n\n  private readonly communicator: Communicator;\n\n  constructor(communicator: Communicator) {\n    this.communicator = communicator;\n    this.call = this.buildRequest<[TransactionConfig, string?], string>({\n      call: RPC_CALLS.eth_call,\n      formatters: [null, inputFormatters.defaultBlockParam],\n    });\n    this.getBalance = this.buildRequest<[string, string?], string>({\n      call: RPC_CALLS.eth_getBalance,\n      formatters: [null, inputFormatters.defaultBlockParam],\n    });\n    this.getCode = this.buildRequest<[string, string?], string>({\n      call: RPC_CALLS.eth_getCode,\n      formatters: [null, inputFormatters.defaultBlockParam],\n    });\n    this.getStorageAt = this.buildRequest<[string, number, string?], string>({\n      call: RPC_CALLS.eth_getStorageAt,\n      formatters: [null, inputFormatters.blockNumberToHex, inputFormatters.defaultBlockParam],\n    });\n    this.getPastLogs = this.buildRequest<[PastLogsOptions], Log[]>({\n      call: RPC_CALLS.eth_getLogs,\n    });\n    this.getBlockByHash = this.buildRequest<[string, boolean?], BlockTransactionString | BlockTransactionObject>({\n      call: RPC_CALLS.eth_getBlockByHash,\n      formatters: [null, inputFormatters.returnFullTxObjectParam],\n    });\n    this.getBlockByNumber = this.buildRequest<\n      [BlockNumberArg, boolean?],\n      BlockTransactionString | BlockTransactionObject\n    >({\n      call: RPC_CALLS.eth_getBlockByNumber,\n      formatters: [inputFormatters.blockNumberToHex, inputFormatters.returnFullTxObjectParam],\n    });\n    this.getTransactionByHash = this.buildRequest<[string], Web3TransactionObject>({\n      call: RPC_CALLS.eth_getTransactionByHash,\n    });\n    this.getTransactionReceipt = this.buildRequest<[string], Web3TransactionReceiptObject>({\n      call: RPC_CALLS.eth_getTransactionReceipt,\n    });\n    this.getTransactionCount = this.buildRequest<[string, string?], string>({\n      call: RPC_CALLS.eth_getTransactionCount,\n      formatters: [null, inputFormatters.defaultBlockParam],\n    });\n    this.getGasPrice = this.buildRequest<never[], string>({\n      call: RPC_CALLS.eth_gasPrice,\n    });\n    this.getEstimateGas = (transaction: TransactionConfig): Promise<number> =>\n      this.buildRequest<[TransactionConfig], number>({\n        call: RPC_CALLS.eth_estimateGas,\n      })([transaction]);\n    this.setSafeSettings = this.buildRequest<[SafeSettings], SafeSettings>({\n      call: RPC_CALLS.safe_setSettings,\n    });\n  }\n\n  private buildRequest<P = never[], R = unknown>(args: BuildRequestArgs) {\n    const { call, formatters } = args;\n\n    return async (params?: P): Promise<R> => {\n      if (formatters && Array.isArray(params)) {\n        formatters.forEach((formatter: ((...args: unknown[]) => unknown) | null, i) => {\n          if (formatter) {\n            params[i] = formatter(params[i]);\n          }\n        });\n      }\n\n      const payload: RPCPayload<P> = {\n        call,\n        params: params || [],\n      };\n\n      const response = await this.communicator.send<Methods.rpcCall, RPCPayload<P>, R>(Methods.rpcCall, payload);\n\n      return response.data;\n    };\n  }\n}\n\nexport { Eth };\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","export const version = '2.31.7'\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport type { AbiFunctionNotFoundErrorType } from '../../errors/abi.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport type { ToFunctionSelectorErrorType } from '../hash/toFunctionSelector.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport type { FormatAbiItemErrorType } from './formatAbiItem.js'\nimport type { GetAbiItemErrorType } from './getAbiItem.js'\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js'\n\nexport type EncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | Hex\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionDataReturnType = Hex\n\nexport type EncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | EncodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function encodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionDataParameters<abi, functionName>,\n): EncodeFunctionDataReturnType {\n  const { args } = parameters as EncodeFunctionDataParameters\n\n  const { abi, functionName } = (() => {\n    if (\n      parameters.abi.length === 1 &&\n      parameters.functionName?.startsWith('0x')\n    )\n      return parameters as { abi: Abi; functionName: Hex }\n    return prepareEncodeFunctionData(parameters)\n  })()\n\n  const abiItem = abi[0]\n  const signature = functionName\n\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, args ?? [])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  type StringToHexErrorType,\n  bytesToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { ErrorType } from '../errors/utils.js'\n\nexport type StringifyErrorType = ErrorType\n\nexport const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","const MAGIC_VALUE = '0x1626ba7e';\nconst MAGIC_VALUE_BYTES = '0x20c13b0b';\n\nexport { MAGIC_VALUE, MAGIC_VALUE_BYTES };\n","export type Permission = {\n  parentCapability: string;\n  invoker: string;\n  date?: number;\n  caveats?: PermissionCaveat[];\n};\n\nexport type PermissionRequest = {\n  [method: string]: Record<string, unknown>;\n};\n\nexport type PermissionCaveat = {\n  type: string;\n  value?: unknown;\n  name?: string;\n};\n\nexport const PERMISSIONS_REQUEST_REJECTED = 4001;\n\nexport class PermissionsError extends Error {\n  public code: number;\n  public data?: unknown;\n\n  constructor(message: string, code: number, data?: unknown) {\n    super(message);\n\n    this.code = code;\n    this.data = data;\n\n    // Should adjust prototype manually because how TS handles the type extension compilation\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, PermissionsError.prototype);\n  }\n}\n","import { Methods, RestrictedMethods } from '../communication/methods.js';\nimport { Communicator } from '../types/index.js';\nimport { PermissionRequest, Permission, PermissionsError, PERMISSIONS_REQUEST_REJECTED } from '../types/permissions.js';\n\nclass Wallet {\n  private readonly communicator: Communicator;\n\n  constructor(communicator: Communicator) {\n    this.communicator = communicator;\n  }\n\n  async getPermissions(): Promise<Permission[]> {\n    const response = await this.communicator.send<Methods.wallet_getPermissions, undefined, Permission[]>(\n      Methods.wallet_getPermissions,\n      undefined,\n    );\n\n    return response.data;\n  }\n\n  async requestPermissions(permissions: PermissionRequest[]): Promise<Permission[]> {\n    if (!this.isPermissionRequestValid(permissions)) {\n      throw new PermissionsError('Permissions request is invalid', PERMISSIONS_REQUEST_REJECTED);\n    }\n\n    try {\n      const response = await this.communicator.send<\n        Methods.wallet_requestPermissions,\n        PermissionRequest[],\n        Permission[]\n      >(Methods.wallet_requestPermissions, permissions);\n\n      return response.data;\n    } catch {\n      throw new PermissionsError('Permissions rejected', PERMISSIONS_REQUEST_REJECTED);\n    }\n  }\n\n  isPermissionRequestValid(permissions: PermissionRequest[]): boolean {\n    return permissions.every((pr: PermissionRequest) => {\n      if (typeof pr === 'object') {\n        return Object.keys(pr).every((method) => {\n          if (Object.values(RestrictedMethods).includes(method as RestrictedMethods)) {\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return false;\n    });\n  }\n}\n\nexport { Wallet };\n","import { Methods } from '../communication/index.js';\nimport { Safe } from '../safe/index.js';\nimport { Wallet } from '../wallet/index.js';\n\nimport { Permission, PermissionsError, PERMISSIONS_REQUEST_REJECTED } from '../types/permissions.js';\n\nconst hasPermission = (required: Methods, permissions: Permission[]): boolean =>\n  permissions.some((permission) => permission.parentCapability === required);\n\nconst requirePermission = () => (_: unknown, propertyKey: string, descriptor: PropertyDescriptor) => {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = async function () {\n    // @ts-expect-error accessing private property from decorator. 'this' context is the class instance\n    const wallet = new Wallet((this as Safe).communicator);\n\n    let currentPermissions = await wallet.getPermissions();\n\n    if (!hasPermission(propertyKey as Methods, currentPermissions)) {\n      currentPermissions = await wallet.requestPermissions([{ [propertyKey as Methods]: {} }]);\n    }\n\n    if (!hasPermission(propertyKey as Methods, currentPermissions)) {\n      throw new PermissionsError('Permissions rejected', PERMISSIONS_REQUEST_REJECTED);\n    }\n\n    return originalMethod.apply(this);\n  };\n\n  return descriptor;\n};\n\nexport default requirePermission;\n","import { encodeFunctionData, Address, hashMessage, hashTypedData } from 'viem';\nimport { MAGIC_VALUE_BYTES, MAGIC_VALUE } from './signatures.js';\nimport { Methods } from '../communication/methods.js';\nimport { RPC_CALLS } from '../eth/constants.js';\nimport {\n  Communicator,\n  ChainInfo,\n  SafeBalances,\n  GetBalanceParams,\n  RPCPayload,\n  TransactionConfig,\n  EnvironmentInfo,\n  AddressBookItem,\n  isObjectEIP712TypedData,\n  EIP712TypedData,\n  SafeInfoExtended,\n} from '../types/index.js';\nimport requirePermission from '../decorators/requirePermissions.js';\n\nclass Safe {\n  private readonly communicator: Communicator;\n\n  constructor(communicator: Communicator) {\n    this.communicator = communicator;\n  }\n\n  async getChainInfo(): Promise<ChainInfo> {\n    const response = await this.communicator.send<Methods.getChainInfo, undefined, ChainInfo>(\n      Methods.getChainInfo,\n      undefined,\n    );\n\n    return response.data;\n  }\n\n  async getInfo(): Promise<SafeInfoExtended> {\n    const response = await this.communicator.send<Methods.getSafeInfo, undefined, SafeInfoExtended>(\n      Methods.getSafeInfo,\n      undefined,\n    );\n\n    return response.data;\n  }\n\n  // There is a possibility that this method will change because we may add pagination to the endpoint\n  async experimental_getBalances({ currency = 'usd' }: GetBalanceParams = {}): Promise<SafeBalances> {\n    const response = await this.communicator.send<Methods.getSafeBalances, { currency: string }, SafeBalances>(\n      Methods.getSafeBalances,\n      {\n        currency,\n      },\n    );\n\n    return response.data;\n  }\n\n  private async check1271Signature(messageHash: string, signature = '0x'): Promise<boolean> {\n    const safeInfo = await this.getInfo();\n\n    const encodedIsValidSignatureCall = encodeFunctionData({\n      abi: [\n        {\n          constant: false,\n          inputs: [\n            {\n              name: '_dataHash',\n              type: 'bytes32',\n            },\n            {\n              name: '_signature',\n              type: 'bytes',\n            },\n          ],\n          name: 'isValidSignature',\n          outputs: [\n            {\n              name: '',\n              type: 'bytes4',\n            },\n          ],\n          payable: false,\n          stateMutability: 'nonpayable',\n          type: 'function',\n        },\n      ] as const,\n      functionName: 'isValidSignature',\n      args: [messageHash as Address, signature as Address],\n    });\n\n    const payload = {\n      call: RPC_CALLS.eth_call,\n      params: [\n        {\n          to: safeInfo.safeAddress,\n          data: encodedIsValidSignatureCall,\n        },\n        'latest',\n      ],\n    };\n    try {\n      const response = await this.communicator.send<Methods.rpcCall, RPCPayload<[TransactionConfig, string]>, string>(\n        Methods.rpcCall,\n        payload,\n      );\n\n      return response.data.slice(0, 10).toLowerCase() === MAGIC_VALUE;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  private async check1271SignatureBytes(messageHash: string, signature = '0x'): Promise<boolean> {\n    const safeInfo = await this.getInfo();\n\n    const encodedIsValidSignatureCall = encodeFunctionData({\n      abi: [\n        {\n          constant: false,\n          inputs: [\n            {\n              name: '_data',\n              type: 'bytes',\n            },\n            {\n              name: '_signature',\n              type: 'bytes',\n            },\n          ],\n          name: 'isValidSignature',\n          outputs: [\n            {\n              name: '',\n              type: 'bytes4',\n            },\n          ],\n          payable: false,\n          stateMutability: 'nonpayable',\n          type: 'function',\n        },\n      ] as const,\n      functionName: 'isValidSignature',\n      args: [messageHash as Address, signature as Address],\n    });\n\n    const payload = {\n      call: RPC_CALLS.eth_call,\n      params: [\n        {\n          to: safeInfo.safeAddress,\n          data: encodedIsValidSignatureCall,\n        },\n        'latest',\n      ],\n    };\n\n    try {\n      const response = await this.communicator.send<Methods.rpcCall, RPCPayload<[TransactionConfig, string]>, string>(\n        Methods.rpcCall,\n        payload,\n      );\n\n      return response.data.slice(0, 10).toLowerCase() === MAGIC_VALUE_BYTES;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  calculateMessageHash(message: string): string {\n    return hashMessage(message);\n  }\n\n  calculateTypedMessageHash(typedMessage: EIP712TypedData): string {\n    const chainId =\n      typeof typedMessage.domain.chainId === 'object'\n        ? typedMessage.domain.chainId.toNumber()\n        : Number(typedMessage.domain.chainId);\n\n    let primaryType = typedMessage.primaryType;\n    if (!primaryType) {\n      const fields = Object.values(typedMessage.types);\n      // We try to infer primaryType (simplified ether's version)\n      const primaryTypes = Object.keys(typedMessage.types).filter((typeName) =>\n        fields.every((dataTypes) => dataTypes.every(({ type }) => type.replace('[', '').replace(']', '') !== typeName)),\n      );\n      if (primaryTypes.length === 0 || primaryTypes.length > 1) throw new Error('Please specify primaryType');\n      primaryType = primaryTypes[0];\n    }\n\n    return hashTypedData({\n      message: typedMessage.message,\n      domain: {\n        ...typedMessage.domain,\n        chainId,\n        verifyingContract: typedMessage.domain.verifyingContract as Address,\n        salt: typedMessage.domain.salt as Address,\n      },\n      types: typedMessage.types,\n      primaryType,\n    });\n  }\n\n  async getOffChainSignature(messageHash: string): Promise<string> {\n    const response = await this.communicator.send<Methods.getOffChainSignature, string, string>(\n      Methods.getOffChainSignature,\n      messageHash,\n    );\n\n    return response.data;\n  }\n\n  async isMessageSigned(message: string | EIP712TypedData, signature = '0x'): Promise<boolean> {\n    let check: (() => Promise<boolean>) | undefined;\n    if (typeof message === 'string') {\n      check = async (): Promise<boolean> => {\n        const messageHash = this.calculateMessageHash(message);\n        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);\n        return messageHashSigned;\n      };\n    }\n\n    if (isObjectEIP712TypedData(message)) {\n      check = async (): Promise<boolean> => {\n        const messageHash = this.calculateTypedMessageHash(message);\n        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);\n        return messageHashSigned;\n      };\n    }\n    if (check) {\n      const isValid = await check();\n\n      return isValid;\n    }\n\n    throw new Error('Invalid message type');\n  }\n\n  async isMessageHashSigned(messageHash: string, signature = '0x'): Promise<boolean> {\n    const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];\n\n    for (const check of checks) {\n      const isValid = await check(messageHash, signature);\n      if (isValid) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async getEnvironmentInfo(): Promise<EnvironmentInfo> {\n    const response = await this.communicator.send<Methods.getEnvironmentInfo, undefined, EnvironmentInfo>(\n      Methods.getEnvironmentInfo,\n      undefined,\n    );\n\n    return response.data;\n  }\n\n  @requirePermission()\n  async requestAddressBook(): Promise<AddressBookItem[]> {\n    const response = await this.communicator.send<Methods.requestAddressBook, undefined, AddressBookItem[]>(\n      Methods.requestAddressBook,\n      undefined,\n    );\n\n    return response.data;\n  }\n}\n\nexport { Safe };\n","import { Communicator } from './types/index.js';\nimport InterfaceCommunicator from './communication/index.js';\nimport { TXs } from './txs/index.js';\nimport { Eth } from './eth/index.js';\nimport { Safe } from './safe/index.js';\nimport { Wallet } from './wallet/index.js';\n\nexport type Opts = {\n  allowedDomains?: RegExp[];\n  debug?: boolean;\n};\n\nclass SafeAppsSDK {\n  private readonly communicator: Communicator;\n  public readonly eth: Eth;\n  public readonly txs: TXs;\n  public readonly safe: Safe;\n  public readonly wallet: Wallet;\n\n  constructor(opts: Opts = {}) {\n    const { allowedDomains = null, debug = false } = opts;\n\n    this.communicator = new InterfaceCommunicator(allowedDomains, debug);\n    this.eth = new Eth(this.communicator);\n    this.txs = new TXs(this.communicator);\n    this.safe = new Safe(this.communicator);\n    this.wallet = new Wallet(this.communicator);\n  }\n}\n\nexport default SafeAppsSDK;\n","import SDK from './sdk.js';\n\nexport default SDK;\nexport * from './sdk.js';\nexport * from './types/index.js';\nexport * from './communication/methods.js';\nexport * from './communication/messageFormatter.js';\nexport { getSDKVersion } from './version.js';\nexport * from './eth/constants.js';\n"],"names":["dec2hex","dec","toString","padStart","generateRequestId","window","len","arr","Uint8Array","crypto","getRandomValues","Array","from","join","generateId","Date","getTime","MessageFormatter","Methods","RestrictedMethods","makeRequest","method","params","id","env","sdkVersion","makeResponse","data","version","success","makeErrorResponse","error","constructor","allowedOrigins","arguments","length","undefined","debugMode","callbacks","Map","isServer","isValidMessage","_ref","origin","source","emptyOrMalformed","sentFromParentEl","this","parent","majorVersionNumber","parseInt","split","allowedSDKVersion","validOrigin","isArray","find","regExp","test","logIncomingMessage","msg","console","info","concat","onParentMessage","handleIncomingMessage","payload","cb","get","delete","send","request","Error","postMessage","Promise","resolve","reject","set","response","addEventListener","isObjectEIP712TypedData","obj","TXs","communicator","getBySafeTxHash","safeTxHash","getTxBySafeTxHash","signMessage","message","messagePayload","signTypedMessage","typedData","txs","sendTransactions","RPC_CALLS","inputFormatters","defaultBlockParam","returnFullTxObjectParam","blockNumberToHex","arg","Number","isInteger","Eth","call","buildRequest","formatters","getBalance","getCode","getStorageAt","getPastLogs","getBlockByHash","getBlockByNumber","getTransactionByHash","getTransactionReceipt","getTransactionCount","getGasPrice","getEstimateGas","transaction","setSafeSettings","args","async","forEach","formatter","i","rpcCall","values","concatHex","result","offset","concatBytes","reduce","acc","x","replace","formatAbiItem","abiItem","includeName","type","InvalidDefinitionTypeError","name","formatAbiParams","inputs","map","param","startsWith","components","slice","formatAbiParam","isHex","value","strict","size","Math","ceil","errorConfig","getDocsUrl","docsBaseUrl","docsPath","docsSlug","BaseError","shortMessage","_errorConfig$getDocsU","_errorConfig","_args$name","details","cause","_args$cause","docsUrl","_objectSpread","super","metaMessages","Object","defineProperty","walk","fn","err","AbiEncodingArrayLengthMismatchError","_ref5","expectedLength","givenLength","AbiEncodingBytesSizeMismatchError","_ref6","expectedSize","AbiEncodingLengthMismatchError","_ref7","AbiFunctionNotFoundError","functionName","AbiItemAmbiguityError","y","BytesSizeMismatchError","_ref12","givenSize","InvalidAbiEncodingTypeError","_ref15","InvalidArrayError","InvalidAddressError","address","IntegerOutOfRangeError","max","min","signed","SizeOverflowError","_ref2","maxSize","LruMap","key","has","firstKey","keys","next","SliceOffsetOutOfBoundsError","position","SizeExceedsPaddingSizeError","targetSize","charAt","toUpperCase","toLowerCase","pad","hexOrBytes","dir","padHex","bytes","paddedBytes","padEnd","padBytes","hex_","hex","assertSize","size_","hexes","_v","toHex","opts","numberToHex","stringToHex","boolToHex","bytesToHex","string","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","encoder","TextEncoder","encode","toBytes","hexToBytes","numberToBytes","boolToBytes","stringToBytes","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","hexString","index","j","nibbleLeft","charCodeAt","nibbleRight","U32_MASK64","_32n","fromBig","n","h","l","lst","le","Ah","Uint32Array","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","anumber","isSafeInteger","abytes","b","ArrayBuffer","isView","_len","lengths","_key","includes","aexists","instance","checkFinished","destroyed","finished","clean","_len2","arrays","_key2","fill","isLE","buffer","byteSwap","word","swap32IfBE","u","utf8ToBytes","str","Hash","createHasher","hashCons","hashC","update","digest","tmp","outputLen","blockLen","create","_0n","_1n","_2n","_7n","_256n","_0x71n","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","round","R","push","t","IOTAS","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","enableXOF","rounds","pos","posOut","state","state32","byteOffset","floor","byteLength","clone","_cloneInto","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","take","finish","writeInto","out","bufferOut","subarray","xofInto","xof","digestInto","aoutput","destroy","to","gen","keccak_256","keccak256","to_","checksumAddressCache","checksumAddress","address_","chainId","hexAddress","substring","hash","addressRegex","isAddressCache","isAddress","options","cacheKey","start","end","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","bytesRegex","integerRegex","encodeAbiParameters","preparedParams","prepareParam","prepareParams","encodeParams","arrayComponents","matches","match","getArrayComponents","_ref3","dynamic","dynamicChild","preparedParam","encoded","_ref4","encodeArray","param_","_ref8","encodeTuple","encodeAddress","encodeBool","_integerRegex$exec","exec","encodeNumber","paramSize","bytesSize","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","tupleRegex","_wrapRegExp","array","formatAbiParameter","abiParameter","_result$array","regex","groups","execTyped","indexed","formatAbiParameters","abiParameters","toSignature","def","signature","active","current","level","valid","normalizeSignature","_abiItem$outputs","stateMutability","outputs","toSignatureHash","sig","toFunctionSelector","toEventSelector","isArgOfType","argType","abiParameterType","every","component","getAmbiguousTypes","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","prepareEncodeFunctionData","parameters","abi","item","isSelector","abiItems","filter","matchedAbiItem","ambiguousTypes","getAbiItem","encodeFunctionData","_parameters$functionN","presignMessagePrefix","hashMessage","message_","raw","toPrefixedMessage","InvalidDomainError","domain","stringify","replacer","space","JSON","InvalidPrimaryTypeError","primaryType","InvalidStructTypeError","getTypesForEIP712Domain","verifyingContract","salt","Boolean","validateReference","hashTypedData","EIP712Domain","validateData","struct","integerMatch","_type","base","bytesMatch","validateTypedData","hashStruct","hashDomain","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","unsortedDeps","findTypeDependencies","deps","sort","encodeType","primaryType_","results","Set","add","prepend","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref0","v","PERMISSIONS_REQUEST_REJECTED","PermissionsError","code","setPrototypeOf","prototype","Wallet","getPermissions","wallet_getPermissions","requestPermissions","permissions","isPermissionRequestValid","wallet_requestPermissions","_unused","pr","hasPermission","required","some","permission","parentCapability","requirePermission","_","propertyKey","descriptor","originalMethod","wallet","currentPermissions","apply","Safe","getChainInfo","getInfo","getSafeInfo","experimental_getBalances","currency","getSafeBalances","check1271Signature","messageHash","safeInfo","encodedIsValidSignatureCall","constant","payable","safeAddress","check1271SignatureBytes","calculateMessageHash","calculateTypedMessageHash","typedMessage","toNumber","fields","primaryTypes","typeName","dataTypes","getOffChainSignature","isMessageSigned","check","isMessageHashSigned","checks","bind","getEnvironmentInfo","requestAddressBook","__decorate","allowedDomains","debug","InterfaceCommunicator","eth","safe"],"sourceRoot":""}